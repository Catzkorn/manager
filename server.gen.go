// Code generated by oto; DO NOT EDIT.

package main

import (
	"context"
	"github.com/gopheracademy/manager/log"
	"github.com/opentracing/opentracing-go"
	"github.com/pacedotdev/oto/otohttp"
	"github.com/uber/jaeger-lib/metrics"
	"net/http"
)

// ConferenceService is a service for managing Conferences
type ConferenceService interface {
	Create(context.Context, CreateConferenceRequest) (*CreateConferenceResponse, error)
	Delete(context.Context, DeleteConferenceRequest) (*DeleteConferenceResponse, error)
	Get(context.Context, GetConferenceRequest) (*GetConferenceResponse, error)
	GetBySlug(context.Context, GetConferenceBySlugRequest) (*GetConferenceResponse, error)
	// Greet prepares a lovely greeting.
	List(context.Context, ListConferenceRequest) (*ListConferenceResponse, error)
}

type conferenceServiceServer struct {
	server            *otohttp.Server
	tracer            opentracing.Tracer
	metricsFactory    metrics.Factory
	logger            log.Factory
	conferenceService ConferenceService
}

// Register adds the ConferenceService to the otohttp.Server.
func RegisterConferenceService(metricsFactory metrics.Factory, tracer opentracing.Tracer, logger log.Factory, server *otohttp.Server, conferenceService ConferenceService) {
	handler := &conferenceServiceServer{
		server:            server,
		tracer:            tracer,
		logger:            logger,
		metricsFactory:    metricsFactory,
		conferenceService: conferenceService,
	}
	server.Register("ConferenceService", "Create", handler.handleCreate)
	server.Register("ConferenceService", "Delete", handler.handleDelete)
	server.Register("ConferenceService", "Get", handler.handleGet)
	server.Register("ConferenceService", "GetBySlug", handler.handleGetBySlug)
	server.Register("ConferenceService", "List", handler.handleList)
}

func (s *conferenceServiceServer) handleCreate(w http.ResponseWriter, r *http.Request) {
	s.logger.For(r.Context()).Info("ConferenceService.Create")

	var request CreateConferenceRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.conferenceService.Create(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *conferenceServiceServer) handleDelete(w http.ResponseWriter, r *http.Request) {
	s.logger.For(r.Context()).Info("ConferenceService.Delete")

	var request DeleteConferenceRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.conferenceService.Delete(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *conferenceServiceServer) handleGet(w http.ResponseWriter, r *http.Request) {
	s.logger.For(r.Context()).Info("ConferenceService.Get")

	var request GetConferenceRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.conferenceService.Get(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *conferenceServiceServer) handleGetBySlug(w http.ResponseWriter, r *http.Request) {
	s.logger.For(r.Context()).Info("ConferenceService.GetBySlug")

	var request GetConferenceBySlugRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.conferenceService.GetBySlug(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

func (s *conferenceServiceServer) handleList(w http.ResponseWriter, r *http.Request) {
	s.logger.For(r.Context()).Info("ConferenceService.List")

	var request ListConferenceRequest
	if err := otohttp.Decode(r, &request); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	response, err := s.conferenceService.List(r.Context(), request)
	if err != nil {
		s.server.OnErr(w, r, err)
		return
	}
	if err := otohttp.Encode(w, r, http.StatusOK, response); err != nil {
		s.server.OnErr(w, r, err)
		return
	}
}

// EventSlot holds information for any sellable/giftable slot we have in the event
// for a Talk or any other activity that requires admission.
type EventSlot struct {
	ID          uint32 `json:"id"`
	Name        string `json:"name"`
	Description string `json:"description"`
	Cost        int    `json:"cost"`
	Capacity    int    `json:"capacity"`
	StartDate   uint64 `json:"startDate"`
	EndDate     uint64 `json:"endDate"`
	// DependsOn means that these two Slots need to be acquired together, user must
	// either buy both Slots or pre-own one of the one it depends on.
	DependsOn *EventSlot `json:"dependsOn"`
	// PurchaseableFrom indicates when this item is on sale, for instance early bird
	// tickets are the first ones to go on sale.
	PurchaseableFrom uint64 `json:"purchaseableFrom"`
	// PuchaseableUntil indicates when this item stops being on sale, for instance
	// early bird tickets can no loger be purchased N months before event.
	PurchaseableUntil uint64 `json:"purchaseableUntil"`
	// AvailableToPublic indicates is this is something that will appear on the tickets
	// purchase page (ie, we can issue sponsor tickets and those cannot be bought
	// individually)
	AvailableToPublic bool `json:"availableToPublic"`
}

// Event is an instance like GopherCon 2020
type Event struct {
	ID        uint32      `json:"id"`
	Name      string      `json:"name"`
	Slug      string      `json:"slug"`
	StartDate uint64      `json:"startDate"`
	EndDate   uint64      `json:"endDate"`
	Location  string      `json:"location"`
	Slots     []EventSlot `json:"slots"`
}

// Conference is a brand like GopherCon
type Conference struct {
	ID     uint32  `json:"id"`
	Name   string  `json:"name"`
	Slug   string  `json:"slug"`
	Events []Event `json:"events"`
}

// CreateConferenceRequest is the request object for ConferenceService.Create.
type CreateConferenceRequest struct {
	Conference Conference `json:"conference"`
}

// CreateConferenceResponse is the response object for ConferenceService.Create.
type CreateConferenceResponse struct {
	Conference Conference `json:"conference"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// DeleteConferenceRequest is the request object for ConferenceService.Delete.
type DeleteConferenceRequest struct {
	ID uint32 `json:"id"`
}

// DeleteConferenceResponse is the response object for ConferenceService.Delete.
type DeleteConferenceResponse struct {
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// GetConferenceRequest is the request object for ConferenceService.Get.
type GetConferenceRequest struct {
	ID uint32 `json:"id"`
}

// GetConferenceResponse is the response object containing a single Conference
type GetConferenceResponse struct {
	// Conference represents an event like GopherCon 2020
	Conference Conference `json:"conference"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}

// GetConferenceBySlugRequest is the request object for
// ConferenceService.GetBySlug.
type GetConferenceBySlugRequest struct {
	Slug string `json:"slug"`
}

// ListConferenceRequest is the request object for ConferenceService.List.
type ListConferenceRequest struct {
}

// ListConferenceResponse is the response object containing a list of Conferences
type ListConferenceResponse struct {
	// Greeting is a nice message welcoming somebody.
	Conferences []Conference `json:"conferences"`
	// Error is string explaining what went wrong. Empty if everything was fine.
	Error string `json:"error,omitempty"`
}
